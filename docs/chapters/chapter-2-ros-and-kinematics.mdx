---
title: Chapter 2 - ROS and Kinematics
---

# Chapter 2 - ROS and Kinematics

## Section 1: Introduction to ROS2

### Learning Outcomes
By the end of this module, you will be able to:
- Understand the core concepts and architecture of ROS2.
- Differentiate between ROS1 and ROS2.
- Set up a basic ROS2 workspace and create a simple package.
- Write a basic ROS2 publisher and subscriber node in Python.
- Utilize common ROS2 command-line tools for introspection (Quigley et al., 2009; Macenski et al., 2020).

### What is ROS2?

ROS (Robot Operating System) is a flexible framework for writing robot software. It's a collection of tools, libraries, and conventions that aim to simplify the task of creating complex and robust robot behavior across a wide variety of robotic platforms. ROS2 is the latest iteration of this framework, re-engineered to address the limitations of ROS1, particularly concerning multi-robot systems, real-time control, and embedded systems (Macenski et al., 2020).

Key features of ROS2 include:
-   **DDS (Data Distribution Service) integration**: Provides robust, real-time, and scalable communication.
-   **Multi-robot support**: Designed for seamless operation with multiple robots.
-   **Quality of Service (QoS)** policies: Allows fine-grained control over communication reliability, latency, and throughput.
-   **Security**: Built-in security features for authentication and encryption.
-   **Language Agnostic**: Supports multiple programming languages, with C++ and Python being the most common.

### ROS1 vs. ROS2: Key Differences

While ROS1 laid the foundation for robot software development, ROS2 introduced significant architectural changes to overcome its predecessors' challenges.

| Feature            | ROS1                                   | ROS2                                                            |
| :----------------- | :------------------------------------- | :-------------------------------------------------------------- |
| **Communication**  | Custom TCP/IP-based (ROS Master)       | DDS (Data Distribution Service)                                 |
| **Multi-robot**    | Challenging, required workarounds      | Native support through DDS                                      |
| **Real-time**      | Limited, best-effort communication     | Improved real-time capabilities with QoS policies               |
| **Platform**       | Linux-centric                          | Cross-platform (Linux, Windows, macOS)                          |
| **Security**       | Limited                                | Built-in security (authentication, encryption)                  |
| **Build System**   | Catkin                                 | Colcon                                                          |

### Setting up a ROS2 Workspace and Package

A ROS2 workspace is a directory where you store your ROS2 packages. A package is the fundamental unit of organization in ROS2, containing source code, build scripts, configuration files, and other resources.

To create a new workspace and package:

```bash
# Create a new workspace directory
mkdir -p ~/ros2_ws/src
cd ~/ros2_ws/src

# Create a new package (e.g., 'my_robot_package')
ros2 pkg create --build-type ament_python my_robot_package --dependencies rclpy

# Navigate back to the workspace root and build
cd ~/ros2_ws
colcon build

# Source the setup files to make the package discoverable
source install/setup.bash
```

### Basic ROS2 Publisher and Subscriber (Python)

Let's create a simple publisher and subscriber node. A publisher sends messages on a topic, and a subscriber receives messages from a topic.

#### Publisher Node (`my_publisher_node.py`)

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalPublisher(Node):
    def __init__(self):
        super().__init__('minimal_publisher')
        self.publisher_ = self.create_publisher(String, 'topic', 10)
        timer_period = 0.5  # seconds
        self.timer = self.create_timer(timer_period, self.timer_callback)
        self.i = 0

    def timer_callback(self):
        msg = String()
        msg.data = 'Hello ROS2: %d' % self.i
        self.publisher_.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        self.i += 1

def main(args=None):
    rclpy.init(args=args)
    minimal_publisher = MinimalPublisher()
    rclpy.spin(minimal_publisher)
    minimal_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Subscriber Node (`my_subscriber_node.py`)

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class MinimalSubscriber(Node):
    def __init__(self):
        super().__init__('minimal_subscriber')
        self.subscription = self.create_subscription(
            String,
            'topic',
            self.listener_callback,
            10)
        self.subscription  # prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)

def main(args=None):
    rclpy.init(args=args)
    minimal_subscriber = MinimalSubscriber()
    rclpy.spin(minimal_subscriber)
    minimal_subscriber.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run these:
1.  Save the files in your `my_robot_package/my_robot_package/` directory.
2.  Add entry points in `setup.py` within `my_robot_package`:

    ```python
    from setuptools import setup

    package_name = 'my_robot_package'

    setup(
        name=package_name,
        version='0.0.0',
        packages=[package_name],
        data_files=[
            ('share/' + package_name, ['package.xml']),
            ('share/' + package_name + '/resource', ['resource/' + package_name]),
        ],
        install_requires=['setuptools'],
        zip_safe=True,
        maintainer='your_name',
        maintainer_email='you@example.com',
        description='TODO: Package description',
        license='TODO: License declaration',
        tests_require=['pytest'],
        entry_points={
            'console_scripts': [
                'talker = my_robot_package.my_publisher_node:main',
                'listener = my_robot_package.my_subscriber_node:main',
            ],
        },
    )
    ```

3.  Build the workspace: `cd ~/ros2_ws && colcon build`
4.  Source the setup files: `source install/setup.bash`
5.  Run the nodes in separate terminals:
    -   `ros2 run my_robot_package talker`
    -   `ros2 run my_robot_package listener`

### Common ROS2 Command-Line Tools

-   `ros2 run <package_name> <executable>`: Run an executable from a package.
-   `ros2 topic list`: List active topics.
-   `ros2 topic echo <topic_name>`: Display messages being published on a topic.
-   `ros2 node list`: List active nodes.
-   `ros2 interface show <message_type>`: Show the definition of a message type.
-   `ros2 param list`: List parameters declared by nodes.

### References

Macenski, S., et al. (2020). ROS 2: The Next Generation Robot Operating System. *IEEE Robotics & Automation Magazine*, 27(1), 18-27.

Quigley, M., et al. (2009, May). ROS: an open-source Robot Operating System. In *ICRA workshop on open source robotics* (Vol. 3, No. 2, p. 5).

---

<h2>Section 2: ROS2 Nodes, Topics, and Services</h2>

<h3>Learning Outcomes</h3>
By the end of this module, you will be able to:
- Define the core ROS2 communication concepts: nodes, topics, and services.
- Understand how nodes communicate using topics for asynchronous data flow.
- Understand how nodes communicate using services for synchronous request-response interactions.
- Implement basic ROS2 publisher, subscriber, service, and client in Python using `rclpy`.
- Utilize command-line tools to interact with ROS2 topics and services.

<h3>Introduction to ROS2 Communication</h3>
ROS2 provides a robust communication infrastructure that allows different components of a robot system to interact. These components, often called "nodes," can be distributed across multiple machines and communicate seamlessly using various mechanisms. The primary communication patterns are **topics** for asynchronous data streaming and **services** for synchronous request-response operations.

<h3>Nodes: The Building Blocks</h3>
A **node** is an executable process that performs computations. In a typical robot system, you might have separate nodes for tasks like:
-   Reading sensor data (e.g., camera node, lidar node).
-   Processing information (e.g., object detection node, localization node).
-   Controlling actuators (e.g., motor control node, gripper node).
-   User interface (e.g., dashboard node).

Each node in ROS2 is typically isolated, promoting modularity and reusability. They communicate with each other using the ROS2 communication mechanisms.

<h3>Topics: Asynchronous Data Streaming</h3>
**Topics** are the most common way for nodes to exchange messages. They implement a publish-subscribe pattern:
-   A **publisher** node sends messages to a named topic.
-   One or more **subscriber** nodes receive messages from that same topic.

This is an asynchronous communication model, meaning the publisher doesn't wait for the subscriber to receive the message. It's ideal for continuous data streams like sensor readings, joint states, or diagnostic information (Quigley et al., 2009).

<h4>Python Example: Publisher and Subscriber</h4>
Here's a basic example of a publisher and subscriber in Python using `rclpy`.

<h5>Publisher Node (`simple_publisher.py`)</h5>

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String # Standard message type for strings

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher_node') # Node name
        self.publisher_ = self.create_publisher(String, 'chat_topic', 10) # (MsgType, topic_name, QoS_depth)
        self.timer = self.create_timer(0.5, self.timer_callback) # Timer for publishing every 0.5s
        self.count = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello from ROS2! Count: {self.count}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.count += 1

def main(args=None):
    rclpy.init(args=args)
    node = SimplePublisher()
    rclpy.spin(node) # Keep node alive until Ctrl+C
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

<h5>Subscriber Node (`simple_subscriber.py`)</h5>

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber_node') # Node name
        self.subscription = self.create_subscription(
            String,
            'chat_topic', # Topic name to subscribe to
            self.listener_callback,
            10)
        self.subscription # Prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = SimpleSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run these examples (assuming they are part of a ROS2 package and built with `colcon`):
1.  Open two separate terminals.
2.  In the first terminal, run the publisher: `ros2 run <your_package_name> simple_publisher`
3.  In the second terminal, run the subscriber: `ros2 run <your_package_name> simple_subscriber`
You should see the subscriber printing the messages published by the publisher.

<h3>Services: Synchronous Request-Response</h3>
**Services** implement a request-response pattern. A **service server** node waits for requests, processes them, and sends back a response. A **service client** node sends a request to a service server and waits for the response. This synchronous model is suitable for operations that require an immediate result, like triggering an action or querying data (Gerkey, 2020).

<h4>Python Example: Service and Client</h4>
<h5>Service Server Example (`add_two_ints_server.py`)</h5>
First, define a custom service type. In your `your_package_name/srv` directory, create `AddTwoInts.srv`:

```
int64 a
int64 b
---
int64 sum
```

Then, regenerate package interfaces by running `colcon build` in your workspace.

```python
import rclpy
from rclpy.node import Node
from your_package_name.srv import AddTwoInts # Import your custom service type

class AddTwoIntsServer(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Add Two Ints Service Ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sending response: sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

<h5>Service Client Example (`add_two_ints_client.py`)</h5>

```python
import sys
import rclpy
from rclpy.node import Node
from rclpy.client import Client
from your_package_name.srv import AddTwoInts

class AddTwoIntsClient(Node):
    def __init__(self):
        super().__init__('add_two_ints_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future) # Wait for response
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    client_node = AddTwoIntsClient()

    if len(sys.argv) != 3:
        client_node.get_logger().error('Usage: ros2 run <your_package_name> add_two_ints_client <int_a> <int_b>')
        sys.exit(1)

    a = int(sys.argv[1])
    b = int(sys.argv[2])
    response = client_node.send_request(a, b)
    client_node.get_logger().info(f'Result of add_two_ints: for {a} + {b} = {response.sum}')

    client_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run these examples (after defining `AddTwoInts.srv` and building your package):
1.  Open two separate terminals.
2.  In the first terminal, run the service server: `ros2 run <your_package_name> add_two_ints_server`
3.  In the second terminal, run the service client: `ros2 run <your_package_name> add_two_ints_client 5 7`
You should see the server logging the incoming request and response, and the client logging the sum.

<h3>References</h3>

Gerkey, B. (2020). *ROS2 Documentation*. Open Robotics. https://docs.ros.org/en/foxy/index.html

Quigley, M., et al. (2009, May). ROS: an open-source Robot Operating System. In *ICRA workshop on open source robotics* (Vol. 3, No. 2, p. 5).

---

<h2>Section 3: Forward Kinematics</h2>

<h3>Forward Kinematics (FK)</h3>

Forward kinematics is the process of computing the pose (position + orientation) of a robot’s end-effector (e.g. a hand, foot, or tool) given the values of all the joint parameters (joint angles for revolute joints, displacements for prismatic joints, etc.).

FK is deterministic: for a given set of joint parameters, the end-effector pose is uniquely determined (assuming no singularity or degenerate configuration).

Mathematically, FK uses rigid-body transformations (e.g. via homogeneous transformation matrices, or via Denavit–Hartenberg (DH) parameters) to propagate from the base of the kinematic chain through each link/joint to the end-effector.

In practice, FK is used in simulation, visualization, and motion planning: given joint encoder readings, FK tells where the “hand” or “foot” is in world space.

---

<h2>Section 4: Inverse Kinematics</h2>

<h3>Inverse kinematics</h3>
Inverse kinematics is the reverse problem: given a desired end-effector pose (position + orientation), compute the joint parameters (angles/displacements) that achieve that pose.

IK is generally more complex than FK: the equations are often non-linear, may have multiple solutions (or none), and solving them may require analytic solutions when possible or numerical methods/optimization when not.

In robotics and humanoid systems especially, IK is crucial for tasks like placing a hand at a target position, foot placement for walking, whole-body posture, manipulation, and balancing.
