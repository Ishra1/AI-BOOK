---
title: ROS2 Nodes, Topics, and Services
---

# ROS2 Nodes, Topics, and Services

## Learning Outcomes
By the end of this module, you will be able to:
- Define the core ROS2 communication concepts: nodes, topics, and services.
- Understand how nodes communicate using topics for asynchronous data flow.
- Understand how nodes communicate using services for synchronous request-response interactions.
- Implement basic ROS2 publisher, subscriber, service, and client in Python using `rclpy`.
- Utilize command-line tools to interact with ROS2 topics and services.

## Introduction to ROS2 Communication

ROS2 provides a robust communication infrastructure that allows different components of a robot system to interact. These components, often called "nodes," can be distributed across multiple machines and communicate seamlessly using various mechanisms. The primary communication patterns are **topics** for asynchronous data streaming and **services** for synchronous request-response operations.

## Nodes: The Building Blocks

A **node** is an executable process that performs computations. In a typical robot system, you might have separate nodes for tasks like:
-   Reading sensor data (e.g., camera node, lidar node).
-   Processing information (e.g., object detection node, localization node).
-   Controlling actuators (e.g., motor control node, gripper node).
-   User interface (e.g., dashboard node).

Each node in ROS2 is typically isolated, promoting modularity and reusability. They communicate with each other using the ROS2 communication mechanisms.

## Topics: Asynchronous Data Streaming

**Topics** are the most common way for nodes to exchange messages. They implement a publish-subscribe pattern:
-   A **publisher** node sends messages to a named topic.
-   One or more **subscriber** nodes receive messages from that same topic.

This is an asynchronous communication model, meaning the publisher doesn't wait for the subscriber to receive the message. It's ideal for continuous data streams like sensor readings, joint states, or diagnostic information (Quigley et al., 2009).

### Python Example: Publisher and Subscriber

Here's a basic example of a publisher and subscriber in Python using `rclpy`.

#### Publisher Node Example (`simple_publisher.py`)

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String # Standard message type for strings

class SimplePublisher(Node):
    def __init__(self):
        super().__init__('simple_publisher_node') # Node name
        self.publisher_ = self.create_publisher(String, 'chat_topic', 10) # (MsgType, topic_name, QoS_depth)
        self.timer = self.create_timer(0.5, self.timer_callback) # Timer for publishing every 0.5s
        self.count = 0

    def timer_callback(self):
        msg = String()
        msg.data = f'Hello from ROS2! Count: {self.count}'
        self.publisher_.publish(msg)
        self.get_logger().info(f'Publishing: "{msg.data}"')
        self.count += 1

def main(args=None):
    rclpy.init(args=args)
    node = SimplePublisher()
    rclpy.spin(node) # Keep node alive until Ctrl+C
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Subscriber Node Example (`simple_subscriber.py`)

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import String

class SimpleSubscriber(Node):
    def __init__(self):
        super().__init__('simple_subscriber_node') # Node name
        self.subscription = self.create_subscription(
            String,
            'chat_topic', # Topic name to subscribe to
            self.listener_callback,
            10)
        self.subscription # Prevent unused variable warning

    def listener_callback(self, msg):
        self.get_logger().info(f'I heard: "{msg.data}"')

def main(args=None):
    rclpy.init(args=args)
    node = SimpleSubscriber()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run these examples (assuming they are part of a ROS2 package and built with `colcon`):
1.  Open two separate terminals.
2.  In the first terminal, run the publisher: `ros2 run <your_package_name> simple_publisher`
3.  In the second terminal, run the subscriber: `ros2 run <your_package_name> simple_subscriber`
You should see the subscriber printing the messages published by the publisher.

## Services: Synchronous Request-Response

**Services** implement a request-response pattern. A **service server** node waits for requests, processes them, and sends back a response. A **service client** node sends a request to a service server and waits for the response. This synchronous model is suitable for operations that require an immediate result, like triggering an action or querying data (Gerkey, 2020).

### Python Example: Service and Client

#### Service Server Example (`add_two_ints_server.py`)

First, define a custom service type. In your `your_package_name/srv` directory, create `AddTwoInts.srv`:

```
int64 a
int64 b
---
int64 sum
```

Then, regenerate package interfaces by running `colcon build` in your workspace.

```python
import rclpy
from rclpy.node import Node
from your_package_name.srv import AddTwoInts # Import your custom service type

class AddTwoIntsServer(Node):
    def __init__(self):
        super().__init__('add_two_ints_server')
        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)
        self.get_logger().info('Add Two Ints Service Ready.')

    def add_two_ints_callback(self, request, response):
        response.sum = request.a + request.b
        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}. Sending response: sum={response.sum}')
        return response

def main(args=None):
    rclpy.init(args=args)
    node = AddTwoIntsServer()
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

#### Service Client Example (`add_two_ints_client.py`)

```python
import sys
import rclpy
from rclpy.node import Node
from rclpy.client import Client
from your_package_name.srv import AddTwoInts

class AddTwoIntsClient(Node):
    def __init__(self):
        super().__init__('add_two_ints_client')
        self.cli = self.create_client(AddTwoInts, 'add_two_ints')
        while not self.cli.wait_for_service(timeout_sec=1.0):
            self.get_logger().info('Service not available, waiting again...')
        self.req = AddTwoInts.Request()

    def send_request(self, a, b):
        self.req.a = a
        self.req.b = b
        self.future = self.cli.call_async(self.req)
        rclpy.spin_until_future_complete(self, self.future) # Wait for response
        return self.future.result()

def main(args=None):
    rclpy.init(args=args)
    client_node = AddTwoIntsClient()

    if len(sys.argv) != 3:
        client_node.get_logger().error('Usage: ros2 run <your_package_name> add_two_ints_client <int_a> <int_b>')
        sys.exit(1)

    a = int(sys.argv[1])
    b = int(sys.argv[2])
    response = client_node.send_request(a, b)
    client_node.get_logger().info(f'Result of add_two_ints: for {a} + {b} = {response.sum}')

    client_node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
```

To run these examples (after defining `AddTwoInts.srv` and building your package):
1.  Open two separate terminals.
2.  In the first terminal, run the service server: `ros2 run <your_package_name> add_two_ints_server`
3.  In the second terminal, run the service client: `ros2 run <your_package_name> add_two_ints_client 5 7`
You should see the server logging the incoming request and response, and the client logging the sum.

## References

Gerkey, B. (2020). *ROS2 Documentation*. Open Robotics. https://docs.ros.org/en/foxy/index.html

Quigley, M., et al. (2009, May). ROS: an open-source Robot Operating System. In *ICRA workshop on open source robotics* (Vol. 3, No. 2, p. 5).